<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2113.3">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    span.s1 {font-kerning: none}
  </style>
</head>
<body>
<p class="p1"><span class="s1">import java.awt.Font; import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import javax.swing.*; import javax.swing.SwingUtilities; /** * @author Zhongyan Lin */ public class ArithmeticSimulator { static final char [] ZERO = new char[]{ '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0', '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0', '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0', '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'}; static void copy(char []x, char [] y) { for (int i=0; i &lt; x.length &amp;&amp; i &lt; y.length; i++) y[i] = x[i]; } static void copyLow(char []x, char [] y) { int i,j; for (i=y.length-1,j=x.length-1; i&gt;=0 &amp;&amp; j&gt;=0; i--,j--) y[i] = x[j]; } static void clear(char [] x) { copy(ZERO,x); } static void set(char [] x, int position, char v) { x[position] = v; } static boolean negativeTest(char []x) { return x[0] == '1'; } static void shiftleft(char x[]) { for (int i=0; i &lt; x.length-1; i++) x[i] = x[i+1]; x[x.length-1] = '0'; } static void shiftright(char x[]) { for (int i=x.length-1; i &gt;1; i--) x[i] = x[i-1]; x[0] = '0'; } static char[] singleDigitAdd(char a, char b, char carryover) { char sum = '0'; if (a == '0' &amp;&amp; b == '0' &amp;&amp; carryover == '0'){sum = '0';carryover='0';} else if (a == '0' &amp;&amp; b == '0' &amp;&amp; carryover == '1'){sum = '1';carryover='0';} else if (a == '0' &amp;&amp; b == '1' &amp;&amp; carryover == '0'){sum = '1';carryover='0';} else if (a == '0' &amp;&amp; b == '1' &amp;&amp; carryover == '1'){sum = '0';carryover='1';} else if (a == '1' &amp;&amp; b == '0' &amp;&amp; carryover == '0'){sum = '1';carryover='0';} else if (a == '1' &amp;&amp; b == '0' &amp;&amp; carryover == '1'){sum = '0';carryover='1';} else if (a == '1' &amp;&amp; b == '1' &amp;&amp; carryover == '0'){sum = '0';carryover='1';} else if (a == '1' &amp;&amp; b == '1' &amp;&amp; carryover == '1'){sum = '1';carryover='1';} return new char[]{sum, carryover}; } //add y to x, x updated static void add(char x[], char y[]) { char carryover = '0'; if (y.length &lt; x.length) { char z[] = new char[x.length]; copy(ZERO,z); copyLow(y,z); y = z; } for (int i=x.length-1; i&gt;=0; i--) { char [] sumcarryover = singleDigitAdd(x[i], y[i], carryover); x[i] = sumcarryover[0]; carryover = sumcarryover[1]; } } static void flip(char x[]) { for (int i=0; i &lt; x.length; i++) if (x[i] == '1') x[i] = '0'; else x[i] = '1'; } // a - b = a + (-b) = a + (flip + addone) static void subtract(char x[], char y[]) // subt y from x { char z[] = new char[x.length]; if (y.length &lt; x.length) { clear(z); copyLow(y,z); } else copy(y,z); flip(z); char one[] = new char[x.length]; copy(ZERO, one); set(one, one.length-1, '1'); add(z, one); add(x,z); } /* (1) The Multiplicand register, ALU, and Product register are all 64 bits wide, with only the Multiplier register containing 32 bits. (2) The multiplication operation starts with the product initialized to 0. The 32-bit multiplicand starts in the right half of the Multiplicand register. (3) Control checks Multiplier0 to determine when to shift the Multiplicand and Multiplier registers and when to write new values into the Product register. (4) If Multiplier0 is 0, then Multiplicand register is shifted left 1 bit and the Multiplier is shifted right 1 bit. (5) If Multiplier0 is 1, then Multiplicand and product registers are added and placed in the Product register. (6) The Multiplicand register is again shifted left 1 bit and the Multiplier is shifted right 1 bit. (7) Process continues 32 times to obtain the product. */ static char [] multiply(char [] multiplicand, char [] multiplier) { char [] Multiplicand = new char[64]; //(1) char [] Product = new char[64]; char [] Multiplier = new char[32]; copy(ZERO,Product); //(2) copy(ZERO,Multiplicand); copyLow(multiplicand, Multiplicand); copy(multiplier,Multiplier); for(int i=0; i &lt; 32; i++) //(7) { char Multiplier0 = Multiplier[31]; //(3) if (Multiplier0 == '0') //(3) { shiftleft(Multiplicand); //(4) shiftright(Multiplier); } else { add(Product, Multiplicand);//(5) showbits(Product); shiftleft(Multiplicand); //(6) shiftright(Multiplier); //(7) } } return Product; } /*(1)The Divisor register, ALU, and Remainder register are all 64 bits wide, with only the Quotient register being 32 bits. (2) The divisor is placed in the left half of Divisor register, (3) the dividend is placed in the Remainder, and the Quotient is set to 0. (4) The Divisor is subtracted from the Remainder, then the result is placed into the Remainder. (5) If the result is negative, then the Remainder value is restored by adding the divisor to the Remainder. (6) A negative Remainder indicates the divisor did not go into the dividend. Control shifts Quotient left 1 bit and places a 0 in the least significant bit. (7) Divisor is shifted right 1 bit and the divide operation repeats. (8) The Divisor is subtracted from the Remainder, then the result is placed into the Remainder. (9) If the Remainder is positive, then the divisor was smaller or equal to the dividend. Control shifts Quotient left 1 bit and places a 1 in the least significant bit. (10) Divisor is shifted right 1 bit and the divide operation repeats. The steps repeat a total of 33 times. */ static char [][] divide(char dividend[], char divisor[]) { char [] Divisor = new char[64]; //(1) char [] Remainder = new char[64];//(1) char [] quotient = new char[32]; //(1) copy(ZERO,Divisor); //(2) copy(divisor, Divisor);//(2) copy(dividend, Remainder); //(3) copy(ZERO, quotient); //(3) for(int round = 0; round &lt; 33; round++) //(7)(10) { subtract(Remainder, Divisor); //(4)(8) showbits(Remainder); if (negativeTest(Remainder)) //(5) { sb.append("\n");sb.append("-"); add(Remainder, Divisor); //(5) shiftleft(quotient); //(6) shiftright(Divisor); //(6) } else { sb.append("\n");sb.append("+"); shiftleft(quotient); set(quotient,31, '1'); //(9) shiftright(Divisor); //(9) } } return new char[][]{quotient, Remainder}; } static void showbits(char []x) { sb.append("\n");sb.append(x); } static char [] itobits(int i, int many) { char [] x = new char[many]; copy(ZERO,x); while(i != 0) { int m = i%2; x[--many] = m==0?'0':'1'; i = i &gt;&gt; 1; } return x; } static int bits2i(char [] x) { int ans = 0; for(int i=0; i &lt; x.length; i++) { ans = ans &lt;&lt; 1; ans += x[i]=='1'?1:0; } return ans; } public static void main(String args[]) { SwingUtilities.invokeLater(new Runnable() { public void run() { JFrame frame = new JFrame(); JTextArea t = new JTextArea(23,70); t.setFont(new Font("monospaced", Font.BOLD, 14)); JScrollPane sp=new JScrollPane(t); frame.getContentPane().add(sp); test(); t.append(sb.toString()); try { InputStream in = this.getClass().getClassLoader().getResourceAsStream("resources/ArithmeticSimulator.txt"); BufferedReader r = new BufferedReader(new InputStreamReader(in)); String aline = null; int jj = 0, kk=0; StringBuffer s = new StringBuffer(); while ( (aline = r.readLine())!= null) { t.append(aline + "\n"); } r.close(); in.close(); } catch (Exception e) { System.out.println(e.toString()); } frame.pack(); frame.setTitle("Arithmetic Simulator"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLocationRelativeTo(null); frame.setVisible(true); } }); } static StringBuilder sb; public static void test() { int N = 10000; int [] x = new int[N]; for (int i=0; i &lt; N; i++) { x[i] = 1+(int)(Math.random()*1000000); } int s=0; long t, t0; t0 = System.nanoTime(); for (int i=0; i &lt; N; i++) for (int j= 0; j &lt; N; j++) s += x[i] + x[j]; t = System.nanoTime() - t0; sb = new StringBuilder(); sb.append("Test 1: Comparison of Speed of Arithmetics"); sb.append("\n");sb.append("Time spent on " + (N*N) + " additions: " + t); t0 = System.nanoTime(); for (int i=0; i &lt; N; i++) for (int j= 0; j &lt; N; j++) s += x[i] - x[j]; t = System.nanoTime() - t0; sb.append("\n");sb.append("Time spent on " + (N*N) + " subtractions: " + t); t0 = System.nanoTime(); for (int i=0; i &lt; N; i++) for (int j= 0; j &lt; N; j++) s += x[i] * x[j]; t = System.nanoTime() - t0; sb.append("\n");sb.append("Time spent on " + (N*N) + " multiplications: " + t); t0 = System.nanoTime(); for (int i=0; i &lt; N; i++) for (int j= 0; j &lt; N; j++) s += x[i] / x[j]; t = System.nanoTime() - t0; sb.append("\n");sb.append("Time spent on " + (N*N) + " divisions: " + t); System.out.println(s); sb.append("\n\nTest 2: Correctness of Addition and Subtraction"); int dividendi = 4785963; char [] dividend = itobits(dividendi, 64); sb.append("\n");sb.append(" x=" + dividendi);showbits(dividend); int divisori = 562; char [] divisor = itobits(divisori, 32); sb.append("\n");sb.append(" y=" +divisori );showbits(divisor); sb.append("\n");sb.append(" actural sum = x+y = " + (dividendi+divisori)); add(dividend,divisor); sb.append("\n");sb.append(" simulated sum = " + bits2i(dividend)); sb.append("\n");sb.append("actural sum - y = x = " + (dividendi)); subtract(dividend,divisor); sb.append("\n");sb.append(" simulated sum - y = " + bits2i(dividend)); sb.append("\n\nTest 3: Correctness of Division"); char [][] y = divide(dividend, divisor); char [] quotient = y[0]; char [] remainder = y[1]; int quotienti = bits2i(quotient); int remainderi = bits2i(remainder); sb.append("\n");sb.append("simulated quotient x/y = " + quotienti + ", remainder=" + remainderi); sb.append("\n");sb.append(" actural quotient = " + (dividendi/divisori) + ", remainder=" + (dividendi%divisori)); sb.append("\n\nTest 4: Correctness of Multiplication"); char product[] = multiply(divisor, quotient); int producti = bits2i(product) ; sb.append("\n");sb.append("simulated product quotient*y = " + producti ); sb.append("\n");sb.append(" actural product quotient*y = " + (quotienti*divisori) ); sb.append("\n\nSource Codes: ArithmeticSimulator.java\n\n"); } }<span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">--Notes--<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1">Computer does computations Arithmetic operations: +='/<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1">Addition = s sequence of single-digit adder<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1">Subtraction x-y = x+(-y)=x+flip(y)+1<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1">Multiplication = multiplicand * multiplier: a sequence of copy, shifting, adding<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1">Multiplier(0)= multiplier &lt;&lt;31&gt;&gt;31</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">02274</span></p>
<p class="p1"><span class="s1">———</span></p>
<p class="p1"><span class="s1">15)3411230</span></p>
<p class="p1"><span class="s1">———</span></p>
<p class="p1"><span class="s1">41</span></p>
<p class="p1"><span class="s1">30</span></p>
<p class="p1"><span class="s1">———</span></p>
<p class="p1"><span class="s1">111</span></p>
<p class="p1"><span class="s1">105</span></p>
<p class="p1"><span class="s1">———</span></p>
<p class="p1"><span class="s1">62</span></p>
<p class="p1"><span class="s1">60</span></p>
<p class="p1"><span class="s1">———</span></p>
<p class="p1"><span class="s1">2</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">0000110010</span></p>
<p class="p1"><span class="s1">———</span></p>
<p class="p1"><span class="s1">1101)10100100011101</span></p>
<p class="p1"><span class="s1">-</span></p>
<p class="p1"><span class="s1">———</span></p>
<p class="p1"><span class="s1">101001101</span></p>
<p class="p1"><span class="s1">-</span></p>
<p class="p1"><span class="s1">———</span></p>
<p class="p1"><span class="s1">1111</span></p>
<p class="p1"><span class="s1">1101</span></p>
<p class="p1"><span class="s1">-</span></p>
<p class="p1"><span class="s1">———</span></p>
<p class="p1"><span class="s1">10000</span></p>
<p class="p1"><span class="s1">11001</span></p>
</body>
</html>
